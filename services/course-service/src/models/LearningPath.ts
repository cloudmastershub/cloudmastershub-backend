import mongoose, { Schema, Document } from 'mongoose';
import { LearningPath, PathwayStep, PathwayStepType, LearningPathProgress, CourseCategory, DifficultyLevel, CourseStatus } from '@cloudmastershub/types';
import { generateSlug, generateUniqueSlug } from '@cloudmastershub/utils';

export interface ILearningPath extends Omit<LearningPath, 'id'>, Document {
  _id: string;
  slug: string;
}

export interface ILearningPathProgress extends Omit<LearningPathProgress, 'id' | 'pathId'>, Document {
  pathId: mongoose.Types.ObjectId;
}

const PathwayStepSchema = new Schema({
  id: { type: String, required: true },
  pathId: { type: String, required: true },
  order: { type: Number, required: true, min: 0 },
  type: { 
    type: String, 
    required: true, 
    enum: ['course', 'lab', 'milestone', 'assessment', 'project', 'reading', 'video', 'discussion']
  },
  title: { type: String, required: true, trim: true },
  description: { type: String, trim: true },
  
  // Content references
  courseId: { type: String },
  labId: { type: String },
  
  // Step configuration
  isRequired: { type: Boolean, default: true },
  isLocked: { type: Boolean, default: false },
  estimatedTimeMinutes: { type: Number, required: true, min: 0 },
  
  // Dependencies and flow
  prerequisites: [{ type: String }], // Step IDs
  unlocks: [{ type: String }], // Step IDs
  
  // Content metadata
  difficulty: { type: String, enum: Object.values(DifficultyLevel) },
  skills: [{ type: String, trim: true }]
}, { 
  _id: false,
  timestamps: true 
});

const LearningPathSchema = new Schema<ILearningPath>({
  title: { 
    type: String, 
    required: true, 
    trim: true,
    maxlength: 200
  },
  description: { 
    type: String, 
    required: true,
    maxlength: 5000
  },
  shortDescription: { 
    type: String,
    maxlength: 300
  },
  category: { 
    type: String, 
    required: true, 
    enum: Object.values(CourseCategory)
  },
  level: { 
    type: String, 
    required: true, 
    enum: Object.values(DifficultyLevel)
  },
  thumbnail: { 
    type: String, 
    default: ''
  },
  instructorId: { 
    type: String, 
    required: true 
  },
  
  // Pricing
  price: { 
    type: Number, 
    required: true, 
    min: 0
  },
  originalPrice: { 
    type: Number, 
    min: 0
  },
  currency: { 
    type: String, 
    default: 'USD',
    uppercase: true
  },
  isFree: { 
    type: Boolean, 
    default: false
  },
  
  // Content structure
  pathway: [PathwayStepSchema],
  totalSteps: { 
    type: Number, 
    default: 0, 
    min: 0
  },
  totalCourses: { 
    type: Number, 
    default: 0, 
    min: 0
  },
  totalLabs: { 
    type: Number, 
    default: 0, 
    min: 0
  },
  estimatedDurationHours: { 
    type: Number, 
    default: 0, 
    min: 0
  },
  
  // Learning outcomes
  objectives: [{ type: String, trim: true }],
  skills: [{ type: String, trim: true }],
  prerequisites: [{ type: String, trim: true }],
  outcomes: [{ type: String, trim: true }],
  
  // Engagement
  rating: { 
    type: Number, 
    default: 0, 
    min: 0, 
    max: 5
  },
  reviewCount: { 
    type: Number, 
    default: 0, 
    min: 0
  },
  enrollmentCount: { 
    type: Number, 
    default: 0, 
    min: 0
  },
  completionRate: { 
    type: Number, 
    default: 0, 
    min: 0, 
    max: 100
  },
  tags: [{ type: String, trim: true }],
  
  // Publishing
  status: { 
    type: String, 
    required: true, 
    enum: Object.values(CourseStatus),
    default: CourseStatus.DRAFT
  },
  isPublished: { 
    type: Boolean, 
    default: false
  },
  publishedAt: { 
    type: Date 
  },
  
  // SEO
  slug: {
    type: String,
    required: true, // Generated by pre-validation middleware
    unique: true,
    trim: true,
    lowercase: true,
    index: true
  },
  metaDescription: { 
    type: String,
    maxlength: 160
  },
  keywords: [{ type: String, trim: true }],
  
  // Features
  includesCertificate: { 
    type: Boolean, 
    default: false
  },
  hasHandsOnLabs: { 
    type: Boolean, 
    default: false
  },
  supportLevel: { 
    type: String, 
    enum: ['basic', 'standard', 'premium'],
    default: 'basic'
  }
}, {
  timestamps: true,
  strict: false, // Allow fields not in schema to be saved
  toJSON: { 
    transform: function(doc, ret) {
      // Use slug as the public ID instead of MongoDB ObjectId
      ret.id = ret.slug;
      ret.pathId = ret.slug; // For backward compatibility with existing APIs
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  },
  toObject: { 
    transform: function(doc, ret) {
      // Use slug as the public ID instead of MongoDB ObjectId
      ret.id = ret.slug;
      ret.pathId = ret.slug; // For backward compatibility with existing APIs
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

// Indexes
LearningPathSchema.index({ category: 1, level: 1 });
LearningPathSchema.index({ instructorId: 1 });
LearningPathSchema.index({ status: 1, isPublished: 1 });
LearningPathSchema.index({ rating: -1 });
LearningPathSchema.index({ enrollmentCount: -1 });
LearningPathSchema.index({ createdAt: -1 });
LearningPathSchema.index({ title: 'text', description: 'text' });
LearningPathSchema.index({ slug: 1 }, { unique: true });

// Pre-validation middleware to generate slug before validation
LearningPathSchema.pre('validate', async function(next) {
  try {
    // Generate slug from title if not provided or if this is a new document
    if (!this.slug && this.title) {
      console.log('ðŸ”§ Generating slug before validation for learning path:', this.title);
      
      let baseSlug: string;
      try {
        baseSlug = generateSlug(this.title);
        console.log('ðŸ”§ Generated base slug:', baseSlug);
      } catch (error: any) {
        console.error('ðŸ”§ Error generating slug:', error);
        // Fallback slug generation
        baseSlug = this.title
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .trim()
          .substring(0, 50);
        console.log('ðŸ”§ Fallback slug:', baseSlug);
      }
      
      if (!baseSlug) {
        baseSlug = `learning-path-${Date.now()}`;
        console.log('ðŸ”§ Emergency fallback slug:', baseSlug);
      }
      
      // For new documents, we can set a simple slug first, uniqueness will be handled in pre-save
      this.slug = baseSlug;
      console.log('ðŸ”§ Set initial slug for validation:', this.slug);
    }
    
    next();
  } catch (error: any) {
    console.error('ðŸ”§ Error in LearningPath pre-validation middleware:', error);
    
    // If slug generation fails completely, set a basic slug to prevent validation error
    if (!this.slug) {
      this.slug = `learning-path-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      console.log('ðŸ”§ Emergency slug set in validation error handler:', this.slug);
    }
    
    next();
  }
});

// Pre-save middleware for final slug uniqueness and other operations  
LearningPathSchema.pre('save', async function(next) {
  try {
    // Ensure uniqueness of slug for new documents or when title changes
    if (this.isNew || this.isModified('title')) {
      console.log('ðŸ”§ Ensuring slug uniqueness for learning path:', this.title);
      
      // Always generate a new slug from the current title when title changes
      const baseSlug = generateSlug(this.title);
      console.log('ðŸ”§ Generated fresh base slug from title:', baseSlug);
      
      try {
        // Use mongoose.model to avoid circular reference
        const LearningPathModel = mongoose.model<ILearningPath>('LearningPath');
        
        // Check for existing slugs to ensure uniqueness
        const existingPaths = await LearningPathModel.find({ 
          slug: { $regex: `^${baseSlug}(-\\d+)?$` } 
        }).select('slug');
        
        const existingSlugs = existingPaths
          .filter(path => path._id.toString() !== this._id.toString())
          .map(path => path.slug);
        
        // Always set the slug, making it unique if necessary
        this.slug = generateUniqueSlug(baseSlug, existingSlugs);
        console.log('ðŸ”§ Set final unique slug:', this.slug);
      } catch (error: any) {
        console.error('ðŸ”§ Error ensuring slug uniqueness:', error);
        // Fallback - append timestamp to make it unique
        this.slug = `${baseSlug}-${Date.now()}`;
        console.log('ðŸ”§ Fallback unique slug:', this.slug);
      }
    }
    
    // Update calculated fields
    this.totalSteps = this.pathway.length;
    this.totalCourses = this.pathway.filter(step => step.type === 'course').length;
    this.totalLabs = this.pathway.filter(step => step.type === 'lab').length;
    this.estimatedDurationHours = Math.ceil(
      this.pathway.reduce((total, step) => total + step.estimatedTimeMinutes, 0) / 60
    );
    
    // Auto-set isFree based on price
    if (this.price === 0) {
      this.isFree = true;
    }
    
    // Handle publishing
    if (this.status === CourseStatus.PUBLISHED && this.isPublished && !this.publishedAt) {
      this.publishedAt = new Date();
    }
    
    if (this.status !== CourseStatus.PUBLISHED || !this.isPublished) {
      this.publishedAt = undefined;
    }
    
    console.log('ðŸ”§ Pre-save middleware completed successfully for learning path');
    next();
  } catch (error: any) {
    console.error('ðŸ”§ Error in LearningPath pre-save middleware:', error);
    
    // If slug generation fails completely, set a basic slug to prevent validation error
    if (!this.slug) {
      this.slug = `learning-path-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      console.log('ðŸ”§ Emergency slug set in error handler:', this.slug);
    }
    
    // Continue with save even if slug generation had issues
    next();
  }
});

// Instance methods
LearningPathSchema.methods.publish = function() {
  this.status = CourseStatus.PUBLISHED;
  this.isPublished = true;
  this.publishedAt = new Date();
  return this.save();
};

LearningPathSchema.methods.unpublish = function() {
  this.status = CourseStatus.DRAFT;
  this.isPublished = false;
  this.publishedAt = undefined;
  return this.save();
};

LearningPathSchema.methods.addStep = function(step: Omit<PathwayStep, 'id' | 'pathId'>) {
  const newStep = {
    ...step,
    id: new mongoose.Types.ObjectId().toString(),
    pathId: this._id.toString(),
    order: step.order || this.pathway.length,
    createdAt: new Date(),
    updatedAt: new Date()
  };
  this.pathway.push(newStep);
  return this.save();
};

LearningPathSchema.methods.removeStep = function(stepId: string) {
  this.pathway = this.pathway.filter((step: any) => step.id !== stepId);
  return this.save();
};

LearningPathSchema.methods.reorderSteps = function(stepOrders: { stepId: string; order: number }[]) {
  stepOrders.forEach(({ stepId, order }) => {
    const step = this.pathway.find((s: any) => s.id === stepId);
    if (step) {
      step.order = order;
    }
  });
  this.pathway.sort((a: any, b: any) => a.order - b.order);
  return this.save();
};

LearningPathSchema.methods.incrementEnrollment = function() {
  this.enrollmentCount += 1;
  return this.save();
};

LearningPathSchema.methods.updateRating = function(newRating: number, newReviewCount: number) {
  this.rating = newRating;
  this.reviewCount = newReviewCount;
  return this.save();
};

// Static methods
LearningPathSchema.statics.findPublished = function() {
  return this.find({ status: CourseStatus.PUBLISHED, isPublished: true });
};

LearningPathSchema.statics.findBySlug = function(slug: string) {
  return this.findOne({ slug });
};

LearningPathSchema.statics.findByInstructor = function(instructorId: string) {
  return this.find({ instructorId });
};

LearningPathSchema.statics.findByCategory = function(category: CourseCategory) {
  return this.find({ category });
};

LearningPathSchema.statics.searchPaths = function(searchTerm: string) {
  return this.find({
    $text: { $search: searchTerm },
    status: CourseStatus.PUBLISHED,
    isPublished: true
  });
};

// Learning Path Progress Schema
const LearningPathProgressSchema = new Schema<ILearningPathProgress>({
  userId: { 
    type: String, 
    required: true 
  },
  pathId: { 
    type: Schema.Types.ObjectId, 
    ref: 'LearningPath', 
    required: true 
  },
  
  // Enrollment
  enrolledAt: { 
    type: Date, 
    required: true, 
    default: Date.now 
  },
  enrollmentType: { 
    type: String, 
    enum: ['free', 'purchased', 'subscription'],
    required: true
  },
  
  // Progress
  progress: { 
    type: Number, 
    default: 0, 
    min: 0, 
    max: 100 
  },
  currentStepId: { 
    type: String 
  },
  completedSteps: [{ type: String }],
  skippedSteps: [{ type: String }],
  
  // Time tracking
  totalTimeSpentMinutes: { 
    type: Number, 
    default: 0, 
    min: 0 
  },
  lastAccessedAt: { 
    type: Date, 
    default: Date.now 
  },
  estimatedCompletionDate: { 
    type: Date 
  },
  
  // Completion
  isCompleted: { 
    type: Boolean, 
    default: false 
  },
  completedAt: { 
    type: Date 
  },
  finalScore: { 
    type: Number, 
    min: 0, 
    max: 100 
  },
  
  // Analytics
  strengths: [{ type: String }],
  weaknesses: [{ type: String }],
  recommendedNextPaths: [{ type: String }]
}, {
  timestamps: true,
  toJSON: { 
    transform: function(doc, ret) {
      ret.pathId = ret.pathId.toString();
      return ret;
    }
  }
});

// Progress indexes
LearningPathProgressSchema.index({ userId: 1, pathId: 1 }, { unique: true });
LearningPathProgressSchema.index({ userId: 1 });
LearningPathProgressSchema.index({ pathId: 1 });
LearningPathProgressSchema.index({ isCompleted: 1 });

// Progress instance methods
LearningPathProgressSchema.methods.markStepComplete = function(stepId: string) {
  if (!this.completedSteps.includes(stepId)) {
    this.completedSteps.push(stepId);
    this.lastAccessedAt = new Date();
  }
  return this.save();
};

LearningPathProgressSchema.methods.setCurrentStep = function(stepId: string) {
  this.currentStepId = stepId;
  this.lastAccessedAt = new Date();
  return this.save();
};

LearningPathProgressSchema.methods.updateProgress = function(progressPercentage: number) {
  this.progress = Math.min(100, Math.max(0, progressPercentage));
  this.lastAccessedAt = new Date();
  
  if (this.progress === 100 && !this.isCompleted) {
    this.isCompleted = true;
    this.completedAt = new Date();
  }
  
  return this.save();
};

const LearningPathModel = mongoose.model<ILearningPath>('LearningPath', LearningPathSchema);
const LearningPathProgressModel = mongoose.model<ILearningPathProgress>('LearningPathProgress', LearningPathProgressSchema);

export { LearningPathModel as LearningPath };
export { LearningPathProgressModel as LearningPathProgress };