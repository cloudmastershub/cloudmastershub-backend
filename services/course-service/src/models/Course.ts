import mongoose, { Schema, Document } from 'mongoose';
import { Course, CourseCategory, DifficultyLevel, CourseStatus } from '@cloudmastershub/types';
import { generateSlug, generateUniqueSlug } from '@cloudmastershub/utils';

// Extend the Course interface to include Mongoose Document methods
export interface ICourse extends Omit<Course, 'id'>, Document {
  _id: string;
  slug: string;
}

const InstructorSchema = new Schema({
  id: { type: String, required: true },
  name: { type: String, required: true },
  email: { type: String, required: false }, // Add email field for frontend compatibility
  avatar: { type: String, required: false, default: 'https://via.placeholder.com/150' },
  bio: { type: String, required: false, default: '' },
  expertise: [{ type: String }],
  rating: { type: Number, default: 0, min: 0, max: 5 }
}, { _id: false });

const ResourceSchema = new Schema({
  id: { type: String, required: true },
  type: { 
    type: String, 
    required: true, 
    enum: ['pdf', 'link', 'code', 'download'] 
  },
  title: { type: String, required: true },
  url: { type: String, required: true },
  size: { type: Number }
}, { _id: false });

const QuestionSchema = new Schema({
  id: { type: String, required: true },
  question: { type: String, required: true },
  options: [{ type: String, required: true }],
  correctAnswer: { type: Number, required: true, min: 0 },
  explanation: { type: String }
}, { _id: false });

const QuizSchema = new Schema({
  id: { type: String, required: true },
  questions: [QuestionSchema],
  passingScore: { type: Number, required: true, min: 0, max: 100 },
  attempts: { type: Number, default: 3, min: 1 }
}, { _id: false });

const LessonSchema = new Schema({
  id: { type: String, required: true },
  sectionId: { type: String, required: true },
  title: { type: String, required: true },
  description: { type: String, required: true },
  videoUrl: { type: String, required: true },
  duration: { type: Number, required: true, min: 0 },
  order: { type: Number, required: true, min: 0 },
  resources: [ResourceSchema],
  quiz: QuizSchema
}, { _id: false });

const SectionSchema = new Schema({
  id: { type: String, required: true },
  title: { type: String, required: true },
  description: { type: String },
  order: { type: Number, required: true, min: 0 },
  lessons: [LessonSchema]
}, { _id: false });

const CourseSchema = new Schema<ICourse>({
  title: { 
    type: String, 
    required: true, 
    trim: true,
    maxlength: 200
  },
  slug: {
    type: String,
    required: true, // Generated by pre-validation middleware
    unique: true,
    trim: true,
    lowercase: true,
    index: true
  },
  description: { 
    type: String, 
    required: true,
    maxlength: 5000 // Increased for detailed course descriptions
  },
  category: { 
    type: String, 
    required: true, 
    enum: Object.values(CourseCategory)
  },
  level: { 
    type: String, 
    required: true, 
    enum: Object.values(DifficultyLevel)
  },
  duration: { 
    type: Number, 
    required: true, 
    min: 0
  },
  thumbnail: { 
    type: String, 
    required: true
  },
  preview: { 
    type: String 
  },
  instructor: { 
    type: InstructorSchema, 
    required: true 
  },
  price: { 
    type: Number, 
    required: true, 
    min: 0
  },
  rating: { 
    type: Number, 
    default: 0, 
    min: 0, 
    max: 5
  },
  enrollmentCount: { 
    type: Number, 
    default: 0, 
    min: 0
  },
  tags: [{ 
    type: String, 
    trim: true
  }],
  requirements: [{ 
    type: String, 
    trim: true
  }],
  objectives: [{ 
    type: String, 
    trim: true
  }],
  curriculum: [SectionSchema],
  status: { 
    type: String, 
    required: true, 
    enum: Object.values(CourseStatus),
    default: CourseStatus.DRAFT
  },
  publishedAt: { 
    type: Date 
  }
}, {
  timestamps: true, // This automatically adds createdAt and updatedAt
  strict: false, // Allow fields not in schema to be saved
  toJSON: { 
    transform: function(doc, ret) {
      // Use slug as the public ID instead of MongoDB ObjectId
      ret.id = ret.slug;
      ret.courseId = ret.slug; // For backward compatibility with existing APIs
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  },
  toObject: { 
    transform: function(doc, ret) {
      // Use slug as the public ID instead of MongoDB ObjectId
      ret.id = ret.slug;
      ret.courseId = ret.slug; // For backward compatibility with existing APIs
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

// Indexes for better query performance
CourseSchema.index({ category: 1, level: 1 });
CourseSchema.index({ 'instructor.id': 1 });
CourseSchema.index({ status: 1 });
CourseSchema.index({ title: 'text', description: 'text' });
CourseSchema.index({ createdAt: -1 });
CourseSchema.index({ rating: -1 });
CourseSchema.index({ enrollmentCount: -1 });
CourseSchema.index({ slug: 1 }, { unique: true });

// Instance methods
CourseSchema.methods.publish = function() {
  this.status = CourseStatus.PUBLISHED;
  this.publishedAt = new Date();
  return this.save();
};

CourseSchema.methods.unpublish = function() {
  this.status = CourseStatus.DRAFT;
  this.publishedAt = undefined;
  return this.save();
};

CourseSchema.methods.archive = function() {
  this.status = CourseStatus.ARCHIVED;
  return this.save();
};

CourseSchema.methods.incrementEnrollment = function() {
  this.enrollmentCount = (this.enrollmentCount || 0) + 1;
  return this.save();
};

CourseSchema.methods.updateRating = function(newRating: number) {
  // This is a simplified rating update - in practice you'd calculate from all reviews
  this.rating = newRating;
  return this.save();
};

// Static methods
CourseSchema.statics.findPublished = function() {
  return this.find({ status: CourseStatus.PUBLISHED });
};

CourseSchema.statics.findBySlug = function(slug: string) {
  return this.findOne({ slug });
};

CourseSchema.statics.findByInstructor = function(instructorId: string) {
  return this.find({ 'instructor.id': instructorId });
};

CourseSchema.statics.findByCategory = function(category: CourseCategory) {
  return this.find({ category });
};

CourseSchema.statics.searchCourses = function(searchTerm: string) {
  return this.find({
    $text: { $search: searchTerm },
    status: CourseStatus.PUBLISHED
  });
};

// Pre-validation middleware to generate slug before validation
CourseSchema.pre('validate', async function(next) {
  try {
    // Generate slug from title if not provided or if this is a new document
    if (!this.slug && this.title) {
      console.log('ðŸ”§ Generating slug before validation for course:', this.title);
      
      let baseSlug: string;
      try {
        baseSlug = generateSlug(this.title);
        console.log('ðŸ”§ Generated base slug:', baseSlug);
      } catch (error) {
        console.error('ðŸ”§ Error generating slug:', error);
        // Fallback slug generation
        baseSlug = this.title
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .trim()
          .substring(0, 50);
        console.log('ðŸ”§ Fallback slug:', baseSlug);
      }
      
      if (!baseSlug) {
        baseSlug = `course-${Date.now()}`;
        console.log('ðŸ”§ Emergency fallback slug:', baseSlug);
      }
      
      // For new documents, we can set a simple slug first, uniqueness will be handled in pre-save
      this.slug = baseSlug;
      console.log('ðŸ”§ Set initial slug for validation:', this.slug);
    }
    
    next();
  } catch (error) {
    console.error('ðŸ”§ Error in Course pre-validation middleware:', error);
    
    // If slug generation fails completely, set a basic slug to prevent validation error
    if (!this.slug) {
      this.slug = `course-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      console.log('ðŸ”§ Emergency slug set in validation error handler:', this.slug);
    }
    
    next();
  }
});

// Pre-save middleware for final slug uniqueness and other operations  
CourseSchema.pre('save', async function(next) {
  try {
    // Ensure uniqueness of slug for new documents or when title changes
    if (this.isNew || this.isModified('title')) {
      console.log('ðŸ”§ Ensuring slug uniqueness for course:', this.title);
      
      // Always generate a new slug from the current title when title changes
      const baseSlug = generateSlug(this.title);
      console.log('ðŸ”§ Generated fresh base slug from title:', baseSlug);
      
      try {
        // Use mongoose.model to avoid circular reference
        const CourseModel = mongoose.model<ICourse>('Course');
        
        // Check for existing slugs to ensure uniqueness
        const existingCourses = await CourseModel.find({ 
          slug: { $regex: `^${baseSlug}(-\\d+)?$` } 
        }).select('slug');
        
        const existingSlugs = existingCourses
          .filter(course => course._id.toString() !== this._id.toString())
          .map(course => course.slug);
        
        // Always set the slug, making it unique if necessary
        this.slug = generateUniqueSlug(baseSlug, existingSlugs);
        console.log('ðŸ”§ Set final unique slug:', this.slug);
      } catch (error) {
        console.error('ðŸ”§ Error ensuring slug uniqueness:', error);
        // Fallback - append timestamp to make it unique
        this.slug = `${baseSlug}-${Date.now()}`;
        console.log('ðŸ”§ Fallback unique slug:', this.slug);
      }
    }
    
    // Auto-publish if status changes to published and no publishedAt date
    if (this.status === CourseStatus.PUBLISHED && !this.publishedAt) {
      this.publishedAt = new Date();
    }
    
    // Clear publishedAt if status is not published
    if (this.status !== CourseStatus.PUBLISHED) {
      this.publishedAt = undefined;
    }
    
    console.log('ðŸ”§ Pre-save middleware completed successfully');
    next();
  } catch (error) {
    console.error('ðŸ”§ Error in Course pre-save middleware:', error);
    
    // If slug generation fails completely, set a basic slug to prevent validation error
    if (!this.slug) {
      this.slug = `course-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      console.log('ðŸ”§ Emergency slug set in error handler:', this.slug);
    }
    
    // Continue with save even if slug generation had issues
    next();
  }
});

const CourseModel = mongoose.model<ICourse>('Course', CourseSchema);
export { CourseModel as Course };